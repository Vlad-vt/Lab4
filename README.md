# Lab4
SOA Lab4

---------------------1. Принципи і протоколи комунікації між сервісами.---------------------

Осоновними способами зв'язку між сервісами є синхронний та асинхронний режими.
У синхронному зв’язку клієнт надсилає запит за допомогою протоколів http і чекає відповіді від служби. Протоколи синхронного зв’язку можуть бути HTTP або HTTPS.
При асинхронному зв’язку клієнт надсилає запит, але не чекає відповіді від служби. Найпопулярнішим протоколом для цього асинхронного зв’язку є AMQP. Асинхронні системи можуть бути реалізовані в режимі «один до одного» або « один до багатьох». У реалізації « один-до-одного» (черги) є один виробник і один отримувач. Але в реалізації «один до багатьох» є кілька приймачів. Кожен запит може бути оброблений від нуля до кількох одержувачів. Зв'язок один-до-багатьох має бути асинхронним.

---------------------2. Яким чином сервіси знаходять екземпляри один одного?---------------------

Існує два типи виявлення служби: на стороні сервера та на стороні клієнта. Виявлення служб на стороні сервера дозволяє клієнтським програмам знаходити служби через маршрутизатор або балансувальник навантаження . Виявлення служб на стороні клієнта дозволяє клієнтським програмам знаходити служби, переглядаючи або запитуючи реєстр послуг, у якому екземпляри та кінцеві точки служб містяться в реєстрі послуг.
Виявлення служби на стороні сервера передбачає розміщення балансувальника навантаження (LB) перед службою та надання балансувальнику навантаження підключення до екземплярів служби. Цей процес усуває складність на стороні клієнта. Клієнт просто вказує на IP або DNS-ім’я балансу навантаження. Такий підхід спрощує виявлення послуг для клієнтів, але LB стає єдиною точкою відмови та вузьким місцем. Крім того, LB має реалізувати логіку виявлення служби, щоб вказувати на правильні екземпляри модулів, запущених у будь-який момент часу.
Інший підхід до виявлення служби полягає у видаленні компонента LB і реалізації виявлення служби на стороні клієнта за допомогою централізованого реєстру послуг. Реєстр послуг містить інформацію про кінцеві точки служби, куди клієнти можуть надсилати запити.
Основна перевага реєстру послуг порівняно з підходом на стороні сервера полягає в тому, що потрібно керувати одним компонентом менше (немає LB) і немає вузьких місць. Однак компроміс полягає в тому, що реєстр послуг ускладнює логіку на стороні клієнта. Клієнт повинен реалізувати логіку, щоб підтримувати реєстр оновленим, щоб він містив найновішу інформацію про серверні модулі/контейнери.

---------------------3. Механізм відслідковування тайм-ауту при ланцюжковому (послідовному) виклику мікросервісів.---------------------

Час від часу ми відчуваємо періодичну повільність роботи програми без очевидних причин. Це могло статися з усіма нами навіть із такими програмами, як google.com. В архітектурі мікросервісу одна служба (A) залежить від іншої служби (B), іноді через певну мережеву проблему служба B може не відповідати належним чином. Ця повільність може вплинути на службу A, оскільки A чекає відповіді від B, щоб продовжити роботу. Оскільки це нерідка проблема, краще взяти до уваги проблему недоступності служби під час розробки мікросервісів. Щоб основні служби працювали належним чином, навіть якщо залежні служби НЕ доступні.
Щоразу, коли у вас є мережевий дзвінок, шукайте випадки успіху та невдачі. Наприклад, якщо ви використовуєте асинхронний API у JavaScript із Promise.then(…), запитайте себе, де знаходиться відповідний .catch(…). Якщо його немає, у вас майже напевно є помилка. У деяких дуже спеціалізованих випадках вам цілком може бути байдуже, успішний чи невдалий запит. UDP є дуже успішним протоколом, який має цю властивість.
Перевірте, чи виконано запит, і повторіть спробу, якщо це безпечно. Ідея тут полягає в тому, що в деяких випадках ми можемо слідувати за нашим запитом про закінчення часу очікування іншим запитом із запитом про статус нашого початкового запиту. Цей підхід явно вимагає існування кінцевої точки, яка може надати нам необхідну інформацію. Враховуючи таку кінцеву точку, якщо кінцева точка повідомляє, що наш запит був успішним, ми можемо остаточно сказати, що нам не потрібно повторювати спробу. Але тут є серйозна проблема: ми не можемо знати, чи безпечна повторна спроба. Тому що загалом запит може бути отриманий нашою віддаленою службою, але все ще оброблятися, і тому кінцева точка запиту, яку ми перевіряємо, не зможе підтвердити успіх. І, звісно, сама перевірка може закінчитися! Віддалений сервер може бути повністю недоступним з тієї ж причини, що й початкова помилка, але навіть якщо це правда, ми все одно не можемо знати, чи виникла проблема до чи після обробки нашого початкового запиту.
